<!DOCTYPE html>
<html>
<head>
<title>Blog - colorBanded</title>
<style type="text/css">
body {
	font-family: "Verdana", "Arial", sans-serif;
	margin: 0;
	padding: 20px 0 0 0;
	background-color: #f6f6f6;
	color: #333333;
	font-size: 12px;
	line-height: 1.4;
}

#container {
	width: 960px;
	margin: 0 auto;
	border: 1px solid #cccccc;
	background-color: #ffffff;
	position: relative;
}

#container:before, #container:after {
	content: "";
	position: absolute;
	z-index: -1;
	background: #999999;
	bottom: 15px;
	width: 50%;
	height: 20px;
	box-shadow: 0 15px 10px #999999;
}

#container:before {
	left: 10px;
	transform: rotate(-3deg);
}

#container:after {
	right: 10px;
	transform: rotate(3deg);
}

#shadow-container {
	width: 980px;
	margin: 0 auto;
	background: url('data:image/gif;base64,R0lGODlhZAAFAIAAAP///8zMzCH5BAAAAAAALAAAAABkAAUAAAIPhI+py+0Po5y02ouz3rwXADs=') repeat-y center;
	padding: 0 10px;
}

#header {
	background: #e0e8f0;
	background-image: url('data:image/gif;base64,R0lGODlhAQAcAIAAAODg4P///yH5BAAAAAAALAAAAAABABwAAAIIhI+py+0PYysAOw==');
	border-bottom: 1px solid #aaaaaa;
	height: 80px;
	padding: 10px;
}

#header h1 {
	margin: 0;
	padding: 0;
	font-size: 24px;
	color: #333333;
	font-weight: normal;
}

#header p {
	margin: 5px 0 0 0;
	font-size: 11px;
	color: #666666;
}

#navigation {
	float: left;
	width: 180px;
	background-color: #f8f8f8;
	border-right: 1px solid #dddddd;
	padding: 10px;
	min-height: 500px;
}

#navigation ul {
	list-style-type: none;
	margin: 0;
	padding: 0;
}

#navigation li {
	margin-bottom: 5px;
}

#navigation a {
	display: block;
	padding: 5px;
	border: 1px solid #dddddd;
	background-color: #f0f0f0;
	color: #0066cc;
	text-decoration: none;
	font-weight: bold;
}

#navigation a:hover {
	background-color: #e0e0e0;
	border-color: #bbbbbb;
	text-decoration: underline;
}

#navigation a.current {
	background-color: #d0d8e0;
	border-color: #999999;
	color: #003366;
}

#content {
	margin-left: 200px;
	padding: 15px;
}

.section {
	margin-bottom: 20px;
	border: 1px solid #dddddd;
	background-color: #ffffff;
}

.section-header {
	background-color: #f0f0f0;
	border-bottom: 1px solid #dddddd;
	padding: 5px 10px;
	font-weight: bold;
	color: #333333;
}

.section-content {
	padding: 10px;
}

.blog-post {
	margin-bottom: 20px;
	padding-bottom: 15px;
	border-bottom: 1px dotted #cccccc;
}

.blog-post:last-child {
	border-bottom: none;
}

.blog-post h3 {
	margin-top: 0;
	margin-bottom: 5px;
	color: #0066cc;
}

.blog-post h3 a {
	color: #0066cc;
	text-decoration: none;
}

.blog-post h3 a:hover {
	text-decoration: underline;
}

.blog-meta {
	font-size: 11px;
	color: #666666;
	font-style: italic;
	margin-bottom: 8px;
}

.blog-excerpt {
	margin-bottom: 8px;
}

.blog-tags {
	font-size: 10px;
	color: #999999;
}

.blog-tags a {
	color: #0066cc;
	text-decoration: none;
	margin-right: 5px;
}

.blog-tags a:hover {
	text-decoration: underline;
}

.loading {
	text-align: center;
	padding: 20px;
	color: #666666;
	font-style: italic;
}

.error {
	background-color: #ffe6e6;
	border: 1px solid #ffcccc;
	padding: 10px;
	color: #cc0000;
}

.info {
	background-color: #e6f3ff;
	border: 1px solid #b3d9ff;
	padding: 10px;
	color: #0066cc;
	margin-bottom: 15px;
}

/* Blog post content styles */
.blog-content {
	line-height: 1.6;
}

.blog-content h1, .blog-content h2, .blog-content h3 {
	color: #333333;
	margin-top: 20px;
	margin-bottom: 10px;
}

.blog-content h1 {
	font-size: 18px;
	border-bottom: 1px solid #dddddd;
	padding-bottom: 5px;
}

.blog-content h2 {
	font-size: 16px;
}

.blog-content h3 {
	font-size: 14px;
}

.blog-content p {
	margin-bottom: 10px;
}

.blog-content code {
	background-color: #f0f0f0;
	border: 1px solid #dddddd;
	padding: 2px 4px;
	font-family: "Courier New", monospace;
	font-size: 11px;
}

.blog-content pre {
	background-color: #f8f8f8;
	border: 1px solid #dddddd;
	padding: 10px;
	overflow-x: auto;
	font-family: "Courier New", monospace;
	font-size: 11px;
}

.blog-content blockquote {
	border-left: 3px solid #cccccc;
	margin-left: 0;
	padding-left: 15px;
	color: #666666;
	font-style: italic;
}

.back-to-blog {
	margin-bottom: 15px;
}

.back-to-blog a {
	color: #0066cc;
	text-decoration: none;
	font-size: 11px;
}

.back-to-blog a:hover {
	text-decoration: underline;
}

.blog-content img {
	max-width: 100%;
	height: auto;
	display: block;
	margin: 15px auto;
	border: 1px solid #dddddd;
	border-radius: 4px;
	box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.blog-content .image-caption {
	text-align: center;
	font-size: 11px;
	color: #666666;
	font-style: italic;
	margin-top: -10px;
	margin-bottom: 15px;
}

/* Mermaid diagram styles */
.blog-content .mermaid {
	text-align: center;
	margin: 20px 0;
	padding: 15px;
	background-color: #fafafa;
	border: 1px solid #e0e0e0;
	border-radius: 4px;
}

.blog-content .mermaid svg {
	max-width: 100%;
	height: auto;
}

/* Mermaid diagram container */
.mermaid-container {
	margin: 20px 0;
	padding: 15px;
	background-color: #fafafa;
	border: 1px solid #e0e0e0;
	border-radius: 4px;
	text-align: center;
}

.mermaid-error {
	background-color: #ffe6e6;
	border: 1px solid #ffcccc;
	color: #cc0000;
	padding: 10px;
	border-radius: 4px;
	margin: 10px 0;
	font-family: monospace;
	font-size: 11px;
}

#footer {
	clear: both;
	background-color: #f0f0f0;
	border-top: 1px solid #dddddd;
	padding: 10px;
	text-align: center;
	font-size: 11px;
	color: #666666;
}

a {
	color: #0066cc;
	text-decoration: underline;
}

a:hover {
	color: #003366;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
<script>
    // Configure Mermaid
    mermaid.initialize({
        startOnLoad: false,
        theme: 'default',
        themeVariables: {
            fontFamily: 'Verdana, Arial, sans-serif',
            fontSize: '12px'
        }
    });
</script>
</head>
<body>
<div id="shadow-container">
  <div id="container">
    <div id="header">
      <h1>colorBanded</h1>
      <p>computer person thing</p>
    </div>
    <div id="navigation">
      <ul>
        <li><a href="index.html">About Me</a></li>
        <li><a href="blog.html" class="current">Blog</a></li>
        <li><a href="links.html">Links & Contact</a></li>
      </ul>
      <div id="blog-stats" style="margin-top: 20px; padding: 10px; border: 1px dashed #cccccc; background-color: #ffffcc; font-size: 11px;">
        <strong>Blog Stats:</strong><br>
        Total Posts: <span id="post-count">Loading...</span><br>
        Last Post: <span id="last-post-date">Loading...</span>
      </div>
      <div style="margin-top: 15px; padding: 8px; border: 1px solid #cccccc; background-color: #f0f8ff; font-size: 10px;">
        <strong>Hosted on:</strong><br>
        <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOEMwIDExLjU0IDIuMjkgMTQuNTMgNS40NyAxNS41OUM1Ljg3IDE1LjY2IDYuMDIgMTUuNDIgNi4wMiAxNS4yMUM2LjAyIDE1LjAyIDYuMDEgMTQuMzkgNi4wMSAxMy43MkM0IDE0LjA5IDMuNDggMTIuNjggMy4yOCAxMS45NUMzLjE3IDExLjU3IDIuNzggMTAuOTYgMi40NCAxMC43NkMyLjE1IDEwLjYgMS43MSAxMC4yMyAxLjcgMTAuMjNDMS43IDEwLjIzIDIuNDQgMTAuMzEgMi44OCAxMC44OEMzLjMgMTEuNDUgMy45NyAxMS4yNCA0LjI4IDExLjA5QzQuMzQgMTAuNTcgNC41NCAxMC4zNSA0Ljc2IDEwLjIyQzMuNDcgMTAuMDkgMi4xNCA5LjU2IDIuMTQgNi44MUMyLjE0IDYuMDMgMi40MiA1LjM5IDIuODkgNC44OUMyLjgyIDQuNzYgMi42IDQuMDMgMi45NiAzLjA2QzIuOTYgMy4wNiAzLjUgMi44NyA2IDQuNzVDNi41IDQuNjMgNy4yNSA0LjU3IDggNC41N0M4Ljc1IDQuNTcgOS41IDQuNjMgMTAgNC43NUMxMi41IDIuODcgMTMuMDQgMy4wNiAxMy4wNCAzLjA2QzEzLjQgNC4wMyAxMy4xOCA0Ljc2IDEzLjExIDQuODlDMTMuNTggNS4zOSAxMy44NiA2LjAzIDEzLjg2IDYuODFDMTMuODYgOS41NiAxMi41MyAxMC4wOSAxMS4yNCAxMC4yMkMxMS40NiAxMC40NSAxMS42NiAxMC44NyAxMS42NiAxMS41M0MxMS42NiAxMi41IDExLjY1IDEzLjI3IDExLjY1IDE1LjIxQzExLjY1IDE1LjQyIDExLjggMTUuNjYgMTIuMiAxNS41OUMxNS43MSAxNC41MyAxNiAxMS41NCAxNiA4QzE2IDMuNTggMTIuNDIgMCA4IDBaIiBmaWxsPSIjMjQyOTJFIi8+Cjwvc3ZnPgo=" alt="GitHub" style="vertical-align: middle; margin-right: 3px;">
        GitHub Pages
      </div>
    </div>
    <div id="content">
      <!-- Blog listing view -->
      <div id="blog-listing">
        <div class="section">
          <div class="section-header">Latest Blog Posts</div>
          <div class="section-content">
            <div class="info"><strong>Feel Free to look around! </strong>Ill post stuff here occasionally.</div>
            <div id="posts-container" class="loading">
              Scanning for blog posts...
            </div>
          </div>
        </div>
      </div>
      
      <!-- Individual blog post view -->
      <div id="blog-post" style="display: none;">
        <div class="back-to-blog">
          <a href="blog.html">&laquo; Back to Blog</a>
        </div>
        <div class="section">
          <div class="section-header" id="post-title">Blog Post</div>
          <div class="section-content">
            <div id="post-meta" class="blog-meta"></div>
            <div id="post-content" class="blog-content"></div>
            <div id="post-tags" class="blog-tags"></div>
          </div>
        </div>
      </div>
    </div>
    <div id="footer">
      &copy; 2025 colorBanded | Hosted on <a href="https://pages.github.com/" target="_blank">GitHub Pages</a> | <a href="#" onclick="alert('Under construction!'); return false;">Site Map</a><br>
      Best viewed in LibreWolf Browser - Github.com/colorbanded
    </div>
  </div>
</div>

<script type="text/javascript">
// GitHub repository configuration
const GITHUB_REPO = {
    owner: 'colorBanded',
    repo: 'colorBanded.github.io',
    branch: 'main',
    postsFolder: 'posts'
};

console.log('Blog script loaded for GitHub Pages, will auto-discover files from:', `${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/${GITHUB_REPO.postsFolder}`);

// Improved markdown parser function with better image and mermaid support
function parseMarkdown(markdown) {
    let html = markdown;
    
    // Step 1: Extract and preserve mermaid blocks first to prevent interference
    const mermaidBlocks = [];
    const mermaidPlaceholders = [];
    
    html = html.replace(/```mermaid\n([\s\S]*?)\n```/gim, (match, content) => {
        const id = `mermaid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const placeholder = `__MERMAID_PLACEHOLDER_${mermaidBlocks.length}__`;
        
        mermaidBlocks.push({
            id: id,
            content: content.trim(),
            placeholder: placeholder
        });
        mermaidPlaceholders.push(placeholder);
        
        return placeholder;
    });
    
    // Step 2: Extract and preserve code blocks to prevent interference
    const codeBlocks = [];
    const codePlaceholders = [];
    
    html = html.replace(/```(\w+)?\n([\s\S]*?)\n```/gim, (match, language, content) => {
        const placeholder = `__CODE_PLACEHOLDER_${codeBlocks.length}__`;
        
        codeBlocks.push({
            language: language || '',
            content: content,
            placeholder: placeholder
        });
        codePlaceholders.push(placeholder);
        
        return placeholder;
    });
    
    // Step 3: Extract and preserve inline code to prevent interference
    const inlineCodeBlocks = [];
    const inlineCodePlaceholders = [];
    
    html = html.replace(/`([^`\n]+)`/gim, (match, content) => {
        const placeholder = `__INLINE_CODE_PLACEHOLDER_${inlineCodeBlocks.length}__`;
        
        inlineCodeBlocks.push({
            content: content,
            placeholder: placeholder
        });
        inlineCodePlaceholders.push(placeholder);
        
        return placeholder;
    });
    
    // Step 4: Process images with better handling
    html = html.replace(/!\[([^\]]*)\]$$([^)]*?)(?:\s+"([^"]*)")?$$/gim, (match, alt, src, title) => {
        // Clean up alt text and title
        const cleanAlt = alt.trim();
        const cleanTitle = title ? title.trim() : '';
        
        // Handle relative paths by converting to GitHub raw URL
        let imageSrc = src.trim();
        if (!imageSrc.startsWith('http') && !imageSrc.startsWith('data:') && !imageSrc.startsWith('/')) {
            imageSrc = `https://raw.githubusercontent.com/${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/${GITHUB_REPO.branch}/${imageSrc}`;
        }
        
        // Build image HTML with proper attributes - FIXED LINE
        const titleValue = cleanTitle ? cleanTitle.replace(/"/g, '&quot;') : undefined;
        const altValue = cleanAlt ? cleanAlt.replace(/"/g, '&quot;') : '';
        
        let imageHtml = `<img src="${imageSrc}" alt="${altValue}"${titleValue ? ` title="${titleValue}"` : ''} loading="lazy">`;
        
        // Add caption if title or alt text exists
        const caption = cleanTitle || cleanAlt;
        if (caption) {
            imageHtml += `<div class="image-caption">${caption}</div>`;
        }
        
        return imageHtml;
    });
    
    // Step 5: Process headers
    html = html.replace(/^#{6}\s+(.*)$/gim, '<h6>$1</h6>');
    html = html.replace(/^#{5}\s+(.*)$/gim, '<h5>$1</h5>');
    html = html.replace(/^#{4}\s+(.*)$/gim, '<h4>$1</h4>');
    html = html.replace(/^#{3}\s+(.*)$/gim, '<h3>$1</h3>');
    html = html.replace(/^#{2}\s+(.*)$/gim, '<h2>$1</h2>');
    html = html.replace(/^#{1}\s+(.*)$/gim, '<h1>$1</h1>');
    
    // Step 6: Process blockquotes (handle multi-line blockquotes)
    html = html.replace(/^>\s*(.*)$/gim, '<blockquote-line>$1</blockquote-line>');
    html = html.replace(/(<blockquote-line>.*<\/blockquote-line>(?:\s*<blockquote-line>.*<\/blockquote-line>)*)/gim, 
        (match) => {
            const content = match.replace(/<blockquote-line>(.*?)<\/blockquote-line>/gim, '$1').replace(/\s*\n\s*/g, '<br>');
            return `<blockquote>${content}</blockquote>`;
        });
    
    // Step 7: Process bold and italic (be more careful with order)
    html = html.replace(/\*\*\*(.*?)\*\*\*/gim, '<strong><em>$1</em></strong>');
    html = html.replace(/\_\_\_(.*?)\_\_\_/gim, '<strong><em>$1</em></strong>');
    html = html.replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>');
    html = html.replace(/\_\_(.*?)\_\_/gim, '<strong>$1</strong>');
    html = html.replace(/\*((?:[^*]|\*(?!\*))*)\*/gim, '<em>$1</em>');
    html = html.replace(/\_((?:[^_]|\_(?!\_))*?)\_/gim, '<em>$1</em>');
    
    // Step 8: Process links
    html = html.replace(/\[([^\]]*)\]$$([^)]*)$$/gim, '<a href="$2">$1</a>');
    
    // Step 9: Process line breaks and paragraphs
    // First, normalize line endings
    html = html.replace(/\r\n/g, '\n');
    html = html.replace(/\r/g, '\n');
    
    // Split into blocks
    const blocks = html.split(/\n\s*\n/);
    const processedBlocks = [];
    
    blocks.forEach(block => {
        block = block.trim();
        if (!block) return;
        
        // Check if block is already wrapped in HTML tags
        if (block.match(/^<(h[1-6]|blockquote|img|div)/i)) {
            processedBlocks.push(block);
        } else {
            // Convert single line breaks to <br> within paragraphs
            const paragraphContent = block.replace(/\n/g, '<br>');
            processedBlocks.push(`<p>${paragraphContent}</p>`);
        }
    });
    
    html = processedBlocks.join('\n\n');
    
    // Step 10: Restore inline code blocks
    inlineCodeBlocks.forEach(codeBlock => {
        html = html.replace(codeBlock.placeholder, `<code>${codeBlock.content}</code>`);
    });
    
    // Step 11: Restore code blocks
    codeBlocks.forEach(codeBlock => {
        const languageClass = codeBlock.language ? ` class="language-${codeBlock.language}"` : '';
        html = html.replace(codeBlock.placeholder, `<pre><code${languageClass}>${codeBlock.content}</code></pre>`);
    });
    
    // Step 12: Restore mermaid blocks
    mermaidBlocks.forEach(mermaidBlock => {
        html = html.replace(mermaidBlock.placeholder, 
            `<div class="mermaid-container"><div class="mermaid" id="${mermaidBlock.id}">${mermaidBlock.content}</div></div>`);
    });
    
    // Step 13: Clean up HTML formatting issues
    
    // Remove empty paragraphs
    html = html.replace(/<p>\s*<\/p>/gim, '');
    
    // Fix paragraphs around block elements
    html = html.replace(/<p>\s*(<h[1-6]>)/gim, '$1');
    html = html.replace(/(<\/h[1-6]>)\s*<\/p>/gim, '$1');
    html = html.replace(/<p>\s*(<blockquote>)/gim, '$1');
    html = html.replace(/(<\/blockquote>)\s*<\/p>/gim, '$1');
    html = html.replace(/<p>\s*(<pre>)/gim, '$1');
    html = html.replace(/(<\/pre>)\s*<\/p>/gim, '$1');
    html = html.replace(/<p>\s*(<div)/gim, '$1');
    html = html.replace(/(<\/div>)\s*<\/p>/gim, '$1');
    
    // Fix images wrapped in paragraphs
    html = html.replace(/<p>\s*(<img[^>]*>)/gim, '$1');
    html = html.replace(/(<img[^>]*>)\s*<\/p>/gim, '$1');
    html = html.replace(/<p>\s*(<div class="image-caption">)/gim, '$1');
    html = html.replace(/(<\/div>)\s*<\/p>/gim, '$1');
    
    // Fix multiple consecutive <br> tags
    html = html.replace(/(<br>\s*){3,}/gim, '<br><br>');
    
    return html;
}

// Enhanced Mermaid rendering function with better error handling
function renderMermaidDiagrams() {
    const mermaidElements = document.querySelectorAll('.mermaid');
    
    if (mermaidElements.length === 0) {
        console.log('No mermaid elements found');
        return;
    }
    
    console.log(`Found ${mermaidElements.length} mermaid diagrams to render`);
    
    mermaidElements.forEach(async (element, index) => {
        try {
            const graphDefinition = element.textContent.trim();
            
            if (!graphDefinition) {
                console.warn(`Mermaid element ${index} is empty`);
                return;
            }
            
            console.log(`Rendering mermaid diagram ${index}:`, graphDefinition.substring(0, 50) + '...');
            
            // Generate unique ID if not present
            if (!element.id) {
                element.id = `mermaid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            }
            
            // Clear the element first
            element.innerHTML = '';
            
            // Add loading indicator
            element.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Rendering diagram...</div>';
            
            // Render the diagram with timeout
            const renderPromise = mermaid.render(element.id + '-svg', graphDefinition);
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Mermaid render timeout')), 10000)
            );
            
            const { svg } = await Promise.race([renderPromise, timeoutPromise]);
            
            // Insert the SVG
            element.innerHTML = svg;
            
            console.log(`Successfully rendered mermaid diagram: ${element.id}`);
            
        } catch (error) {
            console.error(`Error rendering mermaid diagram ${index}:`, error);
            
            // Show user-friendly error
            element.innerHTML = `
                <div class="mermaid-error">
                    <strong>Error rendering diagram:</strong><br>
                    ${error.message}<br>
                    <details style="margin-top: 5px;">
                        <summary style="cursor: pointer; color: #666;">Show diagram source</summary>
                        <pre style="margin-top: 5px; padding: 5px; background: #f5f5f5; border-radius: 3px; font-size: 10px;">${element.textContent.trim()}</pre>
                    </details>
                </div>
            `;
        }
    });
}

// Parse frontmatter from content
function parseFrontmatter(content) {
    const frontmatterRegex = /^---\s*\r?\n([\s\S]*?)\r?\n---\s*\r?\n?([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    
    if (!match) {
        return {
            frontmatter: {},
            content: content
        };
    }
    
    const frontmatterText = match[1];
    const markdownContent = match[2];
    const frontmatter = {};
    
    frontmatterText.split(/\r?\n/).forEach(line => {
        const colonIndex = line.indexOf(':');
        if (colonIndex > -1) {
            const key = line.substring(0, colonIndex).trim();
            const value = line.substring(colonIndex + 1).trim().replace(/^["']|["']$/g, '');
            frontmatter[key] = value;
        }
    });
    
    return {
        frontmatter: frontmatter,
        content: markdownContent.trim()
    };
}

// Enhanced excerpt extraction with better handling
function extractExcerpt(content, maxLength = 150) {
    let excerpt = content;
    
    // Remove frontmatter
    excerpt = excerpt.replace(/^---[\s\S]*?---\s*/gm, '');
    
    // Remove mermaid blocks
    excerpt = excerpt.replace(/```mermaid[\s\S]*?```/gim, '');
    
    // Remove code blocks
    excerpt = excerpt.replace(/```[\s\S]*?```/gim, '');
    
    // Remove inline code
    excerpt = excerpt.replace(/`[^`\n]+`/gim, '');
    
    // Remove images
    excerpt = excerpt.replace(/!\[([^\]]*)\]$$[^)]*$$/gim, '');
    
    // Remove headers
    excerpt = excerpt.replace(/^#{1,6}\s+/gm, '');
    
    // Remove links but keep text
    excerpt = excerpt.replace(/\[([^\]]*)\]$$[^)]*$$/gim, '$1');
    
    // Remove bold/italic markers
    excerpt = excerpt.replace(/\*\*\*(.*?)\*\*\*/gim, '$1');
    excerpt = excerpt.replace(/\*\*(.*?)\*\*/gim, '$1');
    excerpt = excerpt.replace(/\*(.*?)\*/gim, '$1');
    excerpt = excerpt.replace(/\_\_\_(.*?)\_\_\_/gim, '$1');
    excerpt = excerpt.replace(/\_\_(.*?)\_\_/gim, '$1');
    excerpt = excerpt.replace(/\_(.*?)\_/gim, '$1');
    
    // Remove blockquotes
    excerpt = excerpt.replace(/^>\s*/gm, '');
    
    // Clean up whitespace
    excerpt = excerpt.replace(/\s+/g, ' ').trim();
    
    // Truncate if too long
    if (excerpt.length > maxLength) {
        excerpt = excerpt.substring(0, maxLength).trim();
        // Try to break at word boundary
        const lastSpace = excerpt.lastIndexOf(' ');
        if (lastSpace > maxLength * 0.8) {
            excerpt = excerpt.substring(0, lastSpace);
        }
        excerpt += '...';
    }
    
    return excerpt || 'Click to read more...';
}

// Get list of markdown files from GitHub API
async function getPostFilesFromGitHub() {
    try {
        const apiUrl = `https://api.github.com/repos/${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/contents/${GITHUB_REPO.postsFolder}`;
        console.log('Fetching file list from GitHub API:', apiUrl);
        
        const response = await fetch(apiUrl, {
            headers: {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'GitHub-Pages-Blog-Script'
            }
        });
        
        if (!response.ok) {
            throw new Error(`GitHub API request failed: ${response.status}`);
        }
        
        const files = await response.json();
        
        if (!Array.isArray(files)) {
            throw new Error('GitHub API returned non-array response');
        }
        
        const markdownFiles = files
            .filter(file => file.type === 'file' && file.name.endsWith('.md'))
            .map(file => file.name);
        
        console.log('Found markdown files via API:', markdownFiles);
        return markdownFiles;
        
    } catch (error) {
        console.error('GitHub API failed:', error);
        // Fallback: try to discover files by attempting to load common filenames
        return await discoverFilesByAttempt();
    }
}

// Fallback method: try to discover files by attempting to load them using raw.githubusercontent.com
async function discoverFilesByAttempt() {
    console.log('Attempting file discovery by probing common filenames...');
    
    // Common markdown filenames to try
    const commonFilenames = [
        'hello-world.md',
        'first-post.md',
        'welcome.md',
        'test.md',
        'test-post.md',
        'index.md',
        'sample.md',
        'example.md',
        'getting-started.md',
        'introduction.md'
    ];
    
    const foundFiles = [];
    
    for (const filename of commonFilenames) {
        try {
            const fileUrl = `https://raw.githubusercontent.com/${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/${GITHUB_REPO.branch}/${GITHUB_REPO.postsFolder}/${filename}`;
            console.log(`Checking: ${fileUrl}`);
            
            const response = await fetch(fileUrl);
            if (response.ok) {
                const content = await response.text();
                if (content.trim().length > 0) {
                    foundFiles.push(filename);
                    console.log(`Found file: ${filename}`);
                }
            }
        } catch (error) {
            // File doesn't exist or other error, continue checking
            console.log(`File ${filename} not found or error:`, error.message);
        }
    }
    
    console.log('Files found by probing:', foundFiles);
    return foundFiles;
}

// Main function to discover and load blog posts
async function discoverBlogPosts() {
    console.log('Starting blog post discovery...');
    
    const container = document.getElementById('posts-container');
    if (!container) {
        console.error('posts-container element not found');
        return [];
    }
    
    container.innerHTML = '<div class="loading">Discovering blog posts...</div>';
    
    try {
        // Get list of markdown files
        const postFiles = await getPostFilesFromGitHub();
        
        if (postFiles.length === 0) {
            container.innerHTML = `
                <div class="info">
                    <strong>No blog posts found!</strong><br>
                    Make sure you have markdown (.md) files in your posts folder.<br>
                    <strong>Expected location:</strong> 
                    <a href="https://github.com/${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/tree/${GITHUB_REPO.branch}/${GITHUB_REPO.postsFolder}" target="_blank">
                        https://github.com/${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/tree/${GITHUB_REPO.branch}/${GITHUB_REPO.postsFolder}
                    </a><br>
                    <strong>Checked files:</strong> hello-world.md, first-post.md, welcome.md, test.md, test-post.md, index.md, sample.md, example.md, getting-started.md, introduction.md
                </div>
            `;
            return [];
        }
        
        container.innerHTML = `<div class="loading">Loading ${postFiles.length} blog post${postFiles.length !== 1 ? 's' : ''}...</div>`;
        
        // Load each post using raw.githubusercontent.com
        const posts = [];
        for (const filename of postFiles) {
            try {
                const fileUrl = `https://raw.githubusercontent.com/${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/${GITHUB_REPO.branch}/${GITHUB_REPO.postsFolder}/${filename}`;
                console.log(`Loading: ${fileUrl}`);
                
                const response = await fetch(fileUrl);
                if (!response.ok) {
                    console.warn(`Failed to load ${filename}: ${response.status}`);
                    continue;
                }
                
                const content = await response.text();
                if (!content.trim()) {
                    console.warn(`File ${filename} is empty`);
                    continue;
                }
                
                const parsed = parseFrontmatter(content);
                
                const post = {
                    filename: filename,
                    title: parsed.frontmatter.title || filename.replace(/\.md$/, '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    date: parsed.frontmatter.date || new Date().toISOString().split('T')[0],
                    tags: parsed.frontmatter.tags || '',
                    excerpt: parsed.frontmatter.excerpt || extractExcerpt(parsed.content),
                    author: parsed.frontmatter.author || 'colorBanded',
                    content: parsed.content,
                    frontmatter: parsed.frontmatter
                };
                
                posts.push(post);
                console.log(`Loaded post: ${post.title}`);
                
                // Update progress
                container.innerHTML = `<div class="loading">Loaded ${posts.length} of ${postFiles.length} posts...</div>`;
                
            } catch (error) {
                console.error(`Error loading ${filename}:`, error);
            }
        }
        
        // Sort posts by date (newest first)
        posts.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // Display results
        if (posts.length > 0) {
            displayBlogPosts(posts);
            updateBlogStats(posts);
        } else {
            container.innerHTML = `
                <div class="error">
                    <strong>Could not load any blog posts!</strong><br>
                    Found ${postFiles.length} markdown files but failed to load their content.<br>
                    <strong>Troubleshooting:</strong><br>
                    1. Make sure your markdown files are committed to GitHub<br>
                    2. Check that files exist in: <code>${GITHUB_REPO.postsFolder}/</code><br>
                    3. Verify repository is public or accessible<br>
                    4. Check browser console for detailed error messages
                </div>
            `;
        }
        
        return posts;
        
    } catch (error) {
        console.error('Error in discoverBlogPosts:', error);
        container.innerHTML = `
            <div class="error">
                <strong>Error loading blog posts:</strong><br>
                ${error.message}<br>
                Check the browser console for more details.
            </div>
        `;
        return [];
    }
}

// Display blog posts in the listing
function displayBlogPosts(posts) {
    const container = document.getElementById('posts-container');
    if (!container) return;
    
    if (!posts || posts.length === 0) {
        container.innerHTML = '<div class="info">No blog posts to display.</div>';
        return;
    }
    
    let html = '';
    posts.forEach(post => {
        html += `
            <div class="blog-post">
                <h3><a href="#" onclick="loadBlogPost('${post.filename}'); return false;">${post.title}</a></h3>
                <div class="blog-meta">Posted on ${formatDate(post.date)} | By ${post.author}</div>
                <div class="blog-excerpt">
                    <p>${post.excerpt}</p>
                </div>
                ${post.tags ? `<div class="blog-tags">Tags: ${post.tags.split(',').map(tag => `<a href="#" onclick="filterByTag('${tag.trim()}'); return false;">${tag.trim()}</a>`).join(' ')}</div>` : ''}
            </div>
        `;
    });
    
    container.innerHTML = html;
}

// Load and display individual blog post using raw.githubusercontent.com
async function loadBlogPost(filename) {
    try {
        const fileUrl = `https://raw.githubusercontent.com/${GITHUB_REPO.owner}/${GITHUB_REPO.repo}/${GITHUB_REPO.branch}/${GITHUB_REPO.postsFolder}/${filename}`;
        console.log(`Loading post: ${fileUrl}`);
        
        const response = await fetch(fileUrl);
        if (!response.ok) {
            throw new Error(`Could not load blog post: ${response.status} ${response.statusText}`);
        }
        
        const content = await response.text();
        const parsed = parseFrontmatter(content);
        
        // Switch to post view
        const blogListing = document.getElementById('blog-listing');
        const blogPost = document.getElementById('blog-post');
        
        if (blogListing) blogListing.style.display = 'none';
        if (blogPost) blogPost.style.display = 'block';
        
        // Update post content
        const postTitle = document.getElementById('post-title');
        const postMeta = document.getElementById('post-meta');
        const postContent = document.getElementById('post-content');
        const postTags = document.getElementById('post-tags');
        
        if (postTitle) postTitle.textContent = parsed.frontmatter.title || filename.replace(/\.md$/, '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        if (postMeta) postMeta.innerHTML = `Posted on ${formatDate(parsed.frontmatter.date)} | By ${parsed.frontmatter.author || 'colorBanded'}`;
        if (postContent) postContent.innerHTML = parseMarkdown(parsed.content);
        if (postTags && parsed.frontmatter.tags) {
            postTags.innerHTML = `Tags: ${parsed.frontmatter.tags.split(',').map(tag => `<a href="#" onclick="filterByTag('${tag.trim()}'); return false;">${tag.trim()}</a>`).join(' ')}`;
        } else if (postTags) {
            postTags.innerHTML = '';
        }
        
        // Render Mermaid diagrams after content is loaded
        setTimeout(() => {
            renderMermaidDiagrams();
        }, 100);
        
        // Update URL
        if (window.history && window.history.pushState) {
            window.history.pushState({post: filename}, '', `blog.html?post=${filename}`);
        }
        
    } catch (error) {
        console.error('Error loading blog post:', error);
        alert('Error loading blog post: ' + error.message);
    }
}

// Update blog statistics
function updateBlogStats(posts) {
    const postCount = document.getElementById('post-count');
    const lastPostDate = document.getElementById('last-post-date');
    
    if (postCount) postCount.textContent = posts.length;
    if (lastPostDate) {
        if (posts.length > 0) {
            lastPostDate.textContent = formatDate(posts[0].date);
        } else {
            lastPostDate.textContent = 'None';
        }
    }
}

// Format date for display
function formatDate(dateString) {
    if (!dateString) return 'Unknown';
    
    try {
        const date = new Date(dateString);
        if (isNaN(date.getTime())) return dateString;
        
        const months = ['January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'];
        return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
    } catch (error) {
        return dateString;
    }
}

// Filter posts by tag (placeholder for future implementation)
function filterByTag(tag) {
    console.log(`Filter by tag: ${tag}`);
    // TODO: Implement tag filtering
    alert(`Tag filtering coming soon! You clicked: ${tag}`);
}

// Show blog listing view
function showBlogListing() {
    const blogListing = document.getElementById('blog-listing');
    const blogPost = document.getElementById('blog-post');
    
    if (blogListing) blogListing.style.display = 'block';
    if (blogPost) blogPost.style.display = 'none';
    
    if (window.history && window.history.pushState) {
        window.history.pushState({}, '', 'blog.html');
    }
}

// Handle browser back/forward buttons
window.addEventListener('popstate', function(event) {
    if (event.state && event.state.post) {
        loadBlogPost(event.state.post);
    } else {
        showBlogListing();
    }
});

// Check URL parameters on page load
function checkUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);
    const post = urlParams.get('post');
    if (post) {
        loadBlogPost(post);
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing blog...');
    discoverBlogPosts();
    checkUrlParams();
});
</script>
</body>
</html>
